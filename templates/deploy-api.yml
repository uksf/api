parameters:
  - name: environment
    type: string
  - name: serviceName
    type: string
  - name: deployPath
    type: string
  - name: variableGroup
    type: string
  - name: dependsOn
    type: string

stages:
  - stage: Deploy${{ parameters.environment }}
    displayName: Deploy to ${{ parameters.environment }}
    dependsOn: ${{ parameters.dependsOn }}
    variables:
      - group: ${{ parameters.variableGroup }}
    jobs:
      - job: Deploy
        displayName: Deploy
        steps:
          - checkout: none

          - task: PowerShell@2
            displayName: 'Stop Service'
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = "Continue"
                $serviceName = "${{ parameters.serviceName }}"
                $deployPath = "${{ parameters.deployPath }}"
                $serviceTimeout = 60
                $processTimeout = 30

                function Get-TargetProcess {
                    $procs = Get-Process -Name "UKSF.Api" -ErrorAction SilentlyContinue
                    if (-not $procs) { return $null }
                    foreach ($p in @($procs)) {
                        try {
                            $exePath = $p.Path
                            if ($exePath -and $exePath.StartsWith($deployPath, [System.StringComparison]::OrdinalIgnoreCase)) {
                                return $p
                            }
                        } catch {
                            # Access denied - skip this process
                        }
                    }
                    return $null
                }

                function Wait-ProcessExit {
                    param([int]$Timeout = 30)

                    $elapsed = 0
                    while ($elapsed -lt $Timeout) {
                        $proc = Get-TargetProcess
                        if (-not $proc) {
                            Write-Host "Process is no longer running"
                            return $true
                        }
                        Write-Host "Process still running (PID: $($proc.Id), Path: $($proc.Path)), waiting..."
                        Start-Sleep -Seconds 2
                        $elapsed += 2
                    }
                    return $false
                }

                function Wait-FileLockRelease {
                    param([string]$Path, [int]$Timeout = 15)

                    $testFile = Join-Path $Path "UKSF.Api.dll"
                    if (-not (Test-Path $testFile)) {
                        Write-Host "Deploy path does not exist yet, no locks to check"
                        return $true
                    }

                    $elapsed = 0
                    while ($elapsed -lt $Timeout) {
                        try {
                            $stream = [System.IO.File]::Open($testFile, 'Open', 'ReadWrite', 'None')
                            $stream.Close()
                            Write-Host "File locks released"
                            return $true
                        } catch {
                            Write-Host "Files still locked, waiting..."
                            Start-Sleep -Seconds 2
                            $elapsed += 2
                        }
                    }
                    return $false
                }

                # Check if service exists
                $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
                if (-not $service) {
                    Write-Host "Service does not exist"
                    exit 0
                }

                Write-Host "Current service status: $($service.Status)"

                if ($service.Status -eq "Stopped") {
                    Write-Host "Service is already stopped"
                    if (Wait-ProcessExit -Timeout $processTimeout) {
                        Wait-FileLockRelease -Path "${{ parameters.deployPath }}" | Out-Null
                        exit 0
                    }
                    Write-Host "Service stopped but process still running, forcing termination..."
                }

                # Graceful stop
                if ($service.Status -ne "Stopped") {
                    Write-Host "Stopping service: $serviceName"
                    Stop-Service -Name $serviceName -Force -ErrorAction SilentlyContinue

                    $elapsed = 0
                    while ($elapsed -lt $serviceTimeout) {
                        Start-Sleep -Seconds 2
                        $elapsed += 2

                        $service.Refresh()
                        Write-Host "Service status: $($service.Status)"

                        if ($service.Status -eq "Stopped") {
                            Write-Host "Service stopped successfully"
                            break
                        }
                    }
                }

                # Verify process is gone regardless of how service stopped
                if (-not (Wait-ProcessExit -Timeout $processTimeout)) {
                    Write-Host "Process did not exit, forcing termination..."
                    $proc = Get-TargetProcess
                    if ($proc) {
                        Write-Host "Killing process (PID: $($proc.Id), Path: $($proc.Path))"
                        Stop-Process -Id $proc.Id -Force
                    }

                    if (-not (Wait-ProcessExit -Timeout $processTimeout)) {
                        Write-Error "Failed to stop process after force kill"
                        exit 1
                    }
                }

                # Verify file locks are released
                if (-not (Wait-FileLockRelease -Path "${{ parameters.deployPath }}")) {
                    Write-Error "Files still locked after process exit"
                    exit 1
                }

                Write-Host "Service stop complete, files are unlocked"

          - task: CopyFiles@2
            displayName: 'Copy Files'
            inputs:
              SourceFolder: '$(buildOutput)'
              Contents: '**'
              TargetFolder: '${{ parameters.deployPath }}'
              CleanTargetFolder: true
              OverWrite: true

          - task: FileTransform@2
            displayName: 'Transform appsettings'
            inputs:
              folderPath: '${{ parameters.deployPath }}'
              xmlTransformationRules: ''
              jsonTargetFiles: 'appsettings.json'

          - task: PowerShell@2
            displayName: 'Start Service'
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = "Continue"
                $serviceName = "${{ parameters.serviceName }}"
                $timeout = 30

                $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
                if (-not $service) {
                    Write-Error "Service does not exist"
                    exit 1
                }

                Write-Host "Current service status: $($service.Status)"

                if ($service.Status -eq "Running") {
                    Write-Host "Service is already running"
                    exit 0
                }

                Write-Host "Starting service: $serviceName"
                Start-Service -Name $serviceName

                $elapsed = 0
                while ($elapsed -lt $timeout) {
                    Start-Sleep -Seconds 2
                    $elapsed += 2

                    $service.Refresh()
                    Write-Host "Service status: $($service.Status)"

                    if ($service.Status -eq "Running") {
                        Write-Host "Service started successfully"
                        exit 0
                    }
                }

                Write-Error "Service failed to start within $timeout seconds"
                exit 1
